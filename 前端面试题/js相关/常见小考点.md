[toc]



## 事件委托

`DOM2` 级事件流： `事件捕获 -> 目标阶段 -> 事件冒泡`

对于一系列有相同事件行为的 `dom` 元素，我们为每一个元素都注册一个事件监听函数有点太浪费内存和时间了，不如将监听函数注册到父元素上，这样在冒泡阶段事件也能触发。

```js
function delegate(element, eventType, selector, fn) {
    element.addEventListener(eventType, e => {
        let el = e.target
        while (!el.matches(selector)) {
            if (el === element) {
                el = null
                break
            }
            el = el.parentNode
        }
        el && fn.call(el, e, el)
    })
    return element
}
```

## 判断函数是否通过new调用

Js 函数有两个不同的内部方法：`[[Call]] 和 [[Construcor]]`。当通过 new 关键字调用函数时，执行的是 `[[Construcor]]` 函数，它负责创建一个被称为实例的新对象，再执行函数体，将 this 绑定到实例上；不通过 new 调用时，则执行 `[[Call]]` 函数，直接执行函数体。

一般可以通过 this 来检测是不是使用了 new，但当使用 call 等函数手动改变 this 指向时，就不是很准确。

在 ES6 中，当调用函数的 `[[Construcor]]` 函数时， new.target 被赋为 new 操作符的目标，即新创建的实例。如果调用的是 `[[Call]]` 方法，new.target 的值为 `undefined`

```js
function Person(name) {
    if (typeof new.target !== "undefined") {
        this.name = name;
    } else {
        throw new Error("error");
    }
}

var p1 = new Person("Nicholas");
var p2 = Person.call(Person, "miles"); // error
```

## 箭头函数

> “箭头函数”的`this`，总是指向定义时所在的对象，而不是运行时所在的对象。

箭头函数不可改变 this，不能使用 new 调用，因为它没有 constructor 属性

```js
let arrow_func = () => console.log('You just called me')

new arrow_func()
// TypeError: arrow_func is not a constructor
```

