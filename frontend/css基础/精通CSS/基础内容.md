



### 继承不具有任何特殊性

直接给应用到元素上的样式会覆盖继承来的样式，比如：

```html
* {
	color: black;
}

h2 {
	color: gray;
}

<h2><em>Hello</em></h2>
```

文本是黑色而不是灰色



### 外边距折叠

外边距折叠只发生在文档常规文本流中块级盒子的垂直方向上，行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。折叠后的外边距等于边距较大的那一个。



### 可保持宽高比的容器

```js
.wrapper {
    width: 100%;
    height: 0;
    padding-bottom: 75%;
    position: relative;
}

.iframe {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
}
```



### 关于文本与图片的排版

**定位上下文：**

绝对定位：非静态定位的祖先元素或向上追溯到 html 元素

固定定位：浏览器视口

> 在浮动的元素上，与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动的元素。而与浮动方向相同的负外边距会在该方向上把浮动的元素往外拉

* 为什么对浮动的图片设置 `margin-left` 为负值可以把文字拉过来？



### 利用偏移实现自动大小

> 如果没有显示声明元素大小，那么绝对定位元素的大小由自身包含内容来决定；如果各个边都声明了偏移值，那么元素会被拉伸以满足设定的规则



### 堆叠内容的陷阱

堆叠上下文由特定的属性和值创建，任何设定了 `position: absolute` 及值不是 auto 的 z-index 属性的元素，以及设置小于1的 opacity 值的元素都会创建一个自己后代元素的堆叠上下文。比如，C在B的内部，B创建了自己的堆叠上下文且D在B之上，那么无论 C 的 z-index 设置到多大都不会堆叠在D之上。



### 负外边距到底是什么意思



### flex 外边距为 auto 时

> 如果某项一侧的外边距为 auto，而且在容器里那一侧还有空间，那么外边距就会扩展占据可用空间。因此，当 flex 容器内部只有一项元素时，可设置 `margin: auto` 实现在容器内部的垂直水平居中。



### FlexBox 可伸缩属性

`flex: flex-grow flex-shrink flex-basis`

#### flex-grow，默认值0

1. 先利用 flex-basis(设为0，就不会分配任何空间) 确定假想主尺寸
2. 确定实际主尺寸，通过 flex=grow 的系数比例确定如何平分多出的内容

#### flex-shrink，默认值1

计算方法相对麻烦，**反正对于系数相同元素而言，首选尺寸大的项目比首选尺寸小的项目收缩得更多**



### 对行内元素设置 block 利用 line-height 撑开高度

 