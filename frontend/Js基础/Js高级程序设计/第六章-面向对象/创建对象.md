## 工厂模式

```javascript
function createPerson(name, age) {
    var o = new Obejct();
    o.name = name;
    o.age = age;
    o.sayName = function() {
        alert(this.name);
    };
    return o;
}

var person1 = createPerson("ZAYN", 25);
```

工厂模式的问题是没有解决对象识别的问题（怎么知道一个对象的类型）



## 构造函数模式

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.sayName = function() {
        alert(this.name);
    };
}

var person1 = new Person("charlie", 26);
```

按照惯例，构造函数以大写字母开头，非大写字母开头的都是普通函数。

使用 `new` 操作符加一个函数会执行一下步骤：

1. 创建一个新对象；
2. 将构造函数作用域赋给新对象（即 this 指向这个新对象）；
3. 执行构造函数中的代码；
4. 返回新对象；

创建的对象实例有一个 `constructor` 属性，该属性指向构造函数。

```js
alert(person1.constructor == Person); // true
alert(person1.constructor instanceof Person); // true
alert(person1.constructor instanceof Object); // true
```

如果构造函数不通过 `new` 操作符来调用，那么它跟普通函数就没什么区别

```js
var o = new Obejct();
Person.call(o, "shawn", 20);
o.sayName(); // shawn
```

Person 函数在执行的时候 this 指向的是 o。

构造函数的问题是每个方法都要在每个实例上重新创建一遍。

```js
var person2 = new Person("helen", 30);
alert(person1.sayName == person2.sayName); // false
```

因为函数也是对象实例，相当于 `this.sayName = new Function("alert(this.name)");`，所以它们是不同的



## 原型模式

我们创建的每个函数都有一个 `prototype` 原型属性，这是一个指针，指向一个对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法，即原型对象。

```js

```





