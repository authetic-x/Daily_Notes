## 变量

Js 中的变量包括基本类型和引用类型两种。引用类型是保存在内存中的对象，变量所存储的实际上是指向内存地址的指针。所以，当把一个存储对象的变量赋值给另一个变量时，这个变量保存的也是一个指针，这两个变量指向同一个存储在堆中的对象。



### 检测类型

要检测一个变量是不是基本数据类型，typeof 操作符是最佳工具。当我们想知道某个变量是不是对象，或者是什么对象的时候，instanceof 操作符是一个很好的选择

```javascript
person instanceof object; // true
colors instanceof Array; // true
```



## 执行环境及作用域

**执行环境**(execution context)定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中，一般我们的代码无法访问到这个对象。在 Web 浏览器中，全局执行环境是 window 对象。每个函数都有自己的执行环境，当代码在一个环境中执行时，会创建变量对象的一个作用域链，其作用是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。作用域中的下一个变量对象来自外部包含环境，也就是如果一个变量在当前执行环境中没有被找到，就去上一个包含这个函数的环境中找，如果到全局环境都没找到，就会抛出一个错误。

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。



### 没有块级作用域

先来看一个例子

```javascript
if (true) {
    var color = "red";
}

alert(color);
```

在类C语言中，花括号封闭的代码块都有自己的作用域，也就是说理应是无法访问到 color 的；但 Js 中不同，if 语句中声明的变量只会添加到当前的执行环境中，for 也是一样。

再次强调一点，如果初始化变量时没有使用 var 声明，该变量会被添加到全局环境中。当然我们强烈不建议这样做，因为这往往会导致莫名其妙的错误，在严格模式下，初始化不声明会报错。



## 垃圾收集

### 标记清除

当变量进入环境时，这个变量会被标记为“进入环境”，当离开环境时，将其标记为“离开环境“。怎么标记的并不重要，垃圾收集器就是利用类似的标记机制去判断哪些变量不会再被使用了，然后将这些变量清除，回收它们所占用的内存空间。



### 引用计数

这种垃圾收集策略不太常见，原理是跟踪记录每个值被引用的次数，当某个值的引用次数变为0时，就会将其收集。问题是，如果出现循环引用的情况，那么可能那两个对象都不会被清除，从而导致内存泄漏的情况。

如：

```javascript
function problem() {
    var objA = new Object();
    var objB = new Object();
    
    objA.someObj = objB;
    objB.anotherObj = objA;
}
```



### 管理内存

优化内存占用的最佳方式，就是为执行代码只保存必要的数据。一旦数据不再使用，最好用过将其值设置为 null 来释放其引用，这种做法叫解除引用。**这一做法适用于大多数全局变量和全局对象的属性，局部变量会在离开执行环境时被自动解除引用。**

