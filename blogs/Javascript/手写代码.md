# 手写代码

[toc]

## JS原生实现

### instanceof

### apply/call

### bind

### new

### Symbol



## 面试高频

### 深拷贝与浅拷贝

深拷贝我们主要注意两个问题：

1. 边界情况处理
2. 循环引用：使用WeakMap(键必须是Object类型)

```js
function deepClone(obj, hash = new WeakMap()) {
  if (typeof obj !== 'object') return obj;

  const newObj = obj.constructor();
  hash.set(obj, newObj);

  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === 'object') {
      if (hash.get(obj[key])) {
        newObj[key] = obj[key];
      } else {
        newObj[key] = deepClone(obj[key], hash);
      }
    } else {
      newObj[key] = obj[key];
    }
  });

  return newObj;
}
```



### 节流防抖



### 实现私有变量

### 实现无限累加函数

```js
function add(a) {
  function sum(b) {
    a = b ? a + b : a;
    return sum;
  }
  sum.toString = () => a;
  
  return sum;
}
```

#### 柯里化实现多参累加

```js
function add() {
  let args = Array.prototype.slice.call(arguments);
  let fn = () => {
    let arg_fn = Array.prototype.slice.call(arguments);
    return add.apply(null, args.concat(arg_fn));
  }
  fn.toString = () => {
    args.reduce((acc, next) => {
      return acc + next;
    })
  }
  
  return fn;
}

// ES6
function add() {
  let args = [...arguments];
  let fn = () => {
    retutn add.apply(null, args.concat([...arguments]));
  }
  fn.toString = () => args.reduce((acc, next) => acc + next);
  
  return fn;
}
```

