# 手写代码

[toc]

## JS原生实现

### instanceof

### apply/call  

### bind

```js
// MDN -- BIND
if (!Function.prototype.bind) {
    Function.prototype.bind = function(oThis) {
        if (typeof this !== 'function') {
            throw new TypeError(
                "Function.prototype.bind - what is trying " + 
                "to be bound is not callable"
            )
        }

        var args = Array.prototype.slice.call(arguments, 1),
            fToBind = this,
            fNOP = function(){},
            fBound = function() {
                return fToBind.apply(
                    (
                        // 这里是为了new操作有this的优先级
                        this instanceof fNOP && oThis
                        ? this : oThis
                    ),
                    args.concat(Array.prototype.slice.call(arguments))
                )
            }
        
        fNOP.prototype = this.prototype
        // new创建的对象__proto__属性会指向fBound的原型
        fBound.prototype = new fNOP()
        
        return fBound
    }
}
```

### new

> this 绑定的优先级：
>
> `new > 显示绑定 > 上下文绑定 > 默认绑定`

```js
// new操作符的四步操作
1. 创建一个全新的对象
2. 设置新对象的__proto__属性为构造函数([[原型]]连接)
3. 将新对象绑定到函数调用的this
4. 若函数没有返回其它对象，new表达式中的函数会自动返回这个新对象
function New(fn) {
   var obj = Object.create(fn.prototype)
   fn.apply(obj, Array.prototype.slice.call(arguments, 1))
   return obj
}
```

### Symbol



## 面试高频

### 深拷贝与浅拷贝

深拷贝我们主要注意两个问题：

1. 边界情况处理
2. 循环引用：使用WeakMap(键必须是Object类型)

```js
function deepClone(obj, hash = new WeakMap()) {
  if (typeof obj !== 'object') return obj;

  const newObj = obj.constructor();
  hash.set(obj, newObj);

  Object.keys(obj).forEach(key => {
    if (typeof obj[key] === 'object') {
      if (hash.get(obj[key])) {
        newObj[key] = obj[key];
      } else {
        newObj[key] = deepClone(obj[key], hash);
      }
    } else {
      newObj[key] = obj[key];
    }
  });

  return newObj;
}
```

### 节流防抖

#### 节流

```js
function throttle(fn, interval = 300) {
    let canRun = true;
    return function() {
        if (!canRun) return;
        canRun = false;
        setTimeout(() => {
            fn.apply(this, arguments);
            canRun = true;
        }, interval);
    }
}
```

#### 防抖

一定在事件触发n秒后再执行

```js
function debounce(func, wait, immediate) {
    let timeout, result
    const debounced = function() {
        // 解决this指向和event参数的问题
        const context = this
        const args = arguments
        
        if (timeout) clearTimeout(timeout)
        if (immediate) {
            const callNow = !timeout
            timeout = setTimeout(() => {
                timeout = null
            }, wait)
            if (callNow) result = func.apply(context, args)
        } else {
            timeout = setTimeout(() => {
                func.apply(context, args)
            }, wait)
        }

        return result
    }

    debounced.cancel = function() {
        clearTimeout(timeout)
        timeout = null
    }

    return debounced
}
```



### 实现无限累加函数

无限调用某个函数，并且函数返回值会函数调用次数

```js
function add(a) {
  function sum(b) {
    a = b ? a + b : a;
    return sum;
  }
  sum.toString = () => a;
  
  return sum;
}
```

#### 柯里化实现多参累加

```js
function add() {
  let args = Array.prototype.slice.call(arguments);
  let fn = () => {
    let arg_fn = Array.prototype.slice.call(arguments);
    return add.apply(null, args.concat(arg_fn));
  }
  fn.toString = () => {
    args.reduce((acc, next) => {
      return acc + next;
    })
  }
  
  return fn;
}

// ES6
function add() {
  let args = [...arguments];
  let fn = () => {
    retutn add.apply(null, args.concat([...arguments]));
  }
  fn.toString = () => args.reduce((acc, next) => acc + next);
  
  return fn;
}
```

### localStorage实现过期功能

```js
const ls = {
  get(key) {
    const v = JSON.parse(localStorage.getItem(key))
    if (!v) return undefined
    const { value, expire } = v;
    if (value && (expire < Date.now() || !expire)) {
      return value
    }
    return undefined
  },
  set(key, value, expire) {
    const wrappedValue = {
      value
    }
    if (expire) {
      wrappedValue.expire = Date.now() + expire
    }
    localStorage.setItem(key, JSON.stringify(wrappedValue))
  }
}
```

### 洗牌算法

#### shuffle 算法

```js
// return [0, max) + bias
function getRandomInt(max, bias) {
  return Math.floor(Math.random() * Math.floor(max)) + bias;
}

function shuffle(a) {
  var len = a.length;
  for (var i = 0; i < len; i++) {
    var rInt = getRandomInt(len - i, i)
    // 这是重新声明变量，不要瞎用
    // [a[i], a[rInt]] = [a[rInt], a[i]]
    const tmp = a[i]
    a[i] = a[rInt]
    a[rInt] = tmp
  }
  return a;
}
```

#### 扑克牌问题

有一堆扑克牌, 将牌堆第一张放到桌子上, 再将接下来的牌堆的第一张放到牌底, 如此往复；最后桌子上的牌顺序为: (牌底) 1,2,3,4,5,6,7,8,9,10,11,12,13 (牌顶)；问: 原来那堆牌的顺序, 用函数实现;

```js
function pokerQuestion(a) {
  const originSeq = a.map(i => ({
    index: i,
    value: -1
  }))

  let onDesk = true
  let deskSeq = []
  while (originSeq.length) {
    const topPoker = originSeq.splice(0, 1)[0]
    if (onDesk) {
      deskSeq.push(topPoker)
    } else {
      originSeq.push(topPoker)
    }
    onDesk = !onDesk
  }

  for (let i = 1; i <= deskSeq.length; i ++ ) {
    deskSeq[i-1].value = i
  }

  deskSeq = deskSeq.sort((a, b) => a.index - b.index)
  console.log(deskSeq)
  const res = deskSeq.map(poker => poker.value)
  return res
}
```

### 定时器

#### setTimeout 和 setInterval

setInterval 是隔指定的一段时间将处理函数加入到任务队列，但如果任务队列中已有该定时器的代码则不会将函数加入到任务队列，这可能会导致某些间隔被跳过，而某些间隔的执行时间差距又比指定的要短。解决方案是链式调用 setTimeout，它的问题是执行间隔可能被拉长

```js
setTimeout(function() {
    // handle...
    setTimeout(argument.callee, interval);
}, interval);
```

#### 纠正偏差

```js
function clock(fn, interval, maxCount) {
	let count = 0;
	let startTime = Date.getTime();

	function startClock() {
		count++;
		if (maxCount && count >= maxCount) return;
		let offset = Date.getTime() - (startTime + count*interval);
		let nextTime = interval - offset;
        if (nextTime < 0) nextTime = 0;
		setTimeout(fn, nextTime);
	}

	setTimeout(startClock, interval);
}
```

#### 倒计时

```js
// 乞丐版倒计时
window.onload = () => {
	let time = 5;
	const clockEle = document.getElementById('clock')
	const set = setInterval(() => {
		time--
		clockEle.innerHTML = time
		if (time === 0) {
			clockEle.innerHTML = ''
			clearInterval(set)
		}
	}, 1000)

	// setTimeout
	setTimeout()
	function showTime() {
		time--
		clockEle.innerHTML = time
		if (time === 0) {
			clockEle.innerHTML = ''
			clearInterval(set)
		}
		setTimeout(showTime, 1000)
	}
}

//纠偏实现
function tickTock(ms, interval) {
	let count = 0;
	const startTime = Date.getTime()

	function countStart() {
		if (ms <= 0) return
		count++
		let offset = Date.getTime() - (startTime + interval * count)
		let nextTime = interval - offset
		if (nextTime < 0) {
			nextTime = 0
		}
		ms -= interval
		setTimeout(tickTock, nextTime)
	}
}
```

### 私有变量

#### WeakMap

```js
const map = new WeakMap();
class Person {
	constructor(passwd) {
		if (!map.has(this)) {
			map.set(this, {})
		}
		map.get(this).passwd = passwd
	}

	get pwd() {
		return map.get(this).passwd
	}
}
```

直接使用 Map 会造成内存泄漏，因为 Map 保持对 Person 实例的强引用，即使该实例不在被使用，也会常驻内存，所以这里使用 WeakMap

#### Symbol

```js
const widthSymbol = Symbol('width')
class Shape {
	constructor(width) {
		this[widthSymbol] = width
	}

	get getWidth() {
		return this[widthSymbol]
	}
}
```

#### 闭包

```js
function Shape() {
	const this$ = {};

	class Shape {
		constructor(width, height) {
			this$.width = width;
			this$.height = height;
		}

		get area() {
			return this$.width * this$.height;
		}
	}

	return new Shape(...arguments)
}
// 问题是这样写会导致返回的实例如: obj instanceof Shape
// 返回false, 直接改变实例的原型又无法访问area，解决方案有两个：

// 1.
function Shape() {
	const this$ = {};

	class Shape {
		constructor(width, height) {
			this$.width = width;
			this$.height = height;
			Object.defineProperty(this, 'area', () => {
				return this$.width * this$.height;
			});
		}
	}

	return Object.setPrototypeOf(new Shape(...arguments), this);
}

// 2.
function Shape() {
	const this$ = {};

	class Shape {
		constructor(width, height) {
			this$.width = width;
			this$.height = height;
		}

		get area() {
			return this$.width * this$.height;
		}
	}

	const instance = new Shape(...arguments)
	Object.setPrototypeOf(Object.getPrototypeOf(instance), this);
	return instance;
}
```

### EventEmitter

```js
class Event {
  constructor() {
    this._cache = {}
  }

  addEventListener(type, callback) {
    let fns = (this._cache[type] = this._cache[type] || [])
    if (callback && fns.indexOf(callback) === -1) {
      fns.push(callback)
    }
  }

  emit(type, args) {
    if (this._cache[type]) {
      this._cache[type].forEach(fn => fn.apply(this, args))
    }
  }

  removeEventListener(type, callback) {
    if (this._cache[type]) {
      if (callback) {
        const i = this._cache[type].indexOf(callback)
        if (i !== -1) this._cache[type].splice(i, 1)
      } else {
        this._cache[type] = []
      }
    }
  }
}
```

