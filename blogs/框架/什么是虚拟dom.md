## 前言

虚拟 DOM 是前端比较热门的话题，要写一个现代的 MVVM 框架几乎都绕不开虚拟 DOM。那么究竟什么是虚拟 DOM 呢？



## 为什么需要虚拟 DOM？

前端开发页面要做的事情无非就是**维护状态，更新视图**。在传统的 MVC 开发模式中，我们维护一份视图的状态，每当状态数据发生改变，我们都要用 JS 或者 JQuery 去操作 DOM，当应用程序变得越来越复杂时，我们需要维护的状态变得非常的多，操作起来十分麻烦。后来，开发者决定将状态和视图进行双向绑定，一旦状态发生改变，就用模板引擎去重新渲染整个视图。这样做最大的问题就是性能很差，如果一个小的状态改变都要去重新构造整颗 DOM 树，性价比太低。

那么我们能不能比对一下要更新的 DOM 直接的差异，只修改变化的地方。但直接比对 DOM 是不现实的，因为一个 DOM 元素包含了庞大的属性，这是标准决定的；而且操作 DOM 时还要十分小心，轻微的触碰就可能导致重排。

开发者们想到了一个好的办法就是把 DOM 结构表示成简洁的 JS 对象，因为比对的过程并不需要 Element 对象中所有属性。

```js
var element = {
  tagName: 'ul', // 节点标签名
  props: { // DOM的属性，用一个对象存储键值对
    id: 'list'
  },
  children: [ // 该节点的子节点
    {tagName: 'li', props: {class: 'item'}, children: ["Item 1"]},
    {tagName: 'li', props: {class: 'item'}, children: ["Item 2"]},
    {tagName: 'li', props: {class: 'item'}, children: ["Item 3"]},
  ]
}
```

这种结构就被成为虚拟 DOM。



## 如何利用虚拟 DOM 更新页面？

### 1. 构建虚拟 DOM

### 2. 比较两颗虚拟 DOM 的差异

这里的比对过程就涉及到 diff 算法，这里先简单的提一下。diff 算法相当于要比较两棵树的差异，MVVM 框架大都采用同级节点比较，时间复杂度为 O(n)。节点的差异无非以下四种：

* 替换掉原来的节点
* 移动、删除、新增子节点
* 修改了节点的属性
* 对于文本节点，文本内容可能会改变

只要在比对的过程中记住差异的类型和信息，保存在 patches 里面即可。对于第二种差异类型，大多数出现在列表中，如果列表只是顺序发生变化，按照同级比较的原则可能所有的节点都发生了变化，这样一来性能就变差了。所以我们在写列表元素时给它加上一个唯一的 key，就可以告诉框架有哪些节点是可以复用的。

### 3. 将差异应用到真实的DOM上



## 参考

* [深度剖析：如何实现一个 Virtual DOM 算法](https://github.com/livoras/blog/issues/13)
* [React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/)

