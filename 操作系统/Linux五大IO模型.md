### 同步和异步

个人认为它们的主要区别在于消息通知机制。比如，以同步的方式调用一个函数或进行某个任务，调用必须显示的等待函数的返回或任务的完成，可能是阻塞在那里，也可能是轮询，总之要主动等待。而异步则是函数在发出调用请求之后就去做自己的事了，完全不理会调用的某个函数是否执行完毕，当被调用的函数完成操作后，再以发出一个信号或者回调的机制去通知调用者任务的完成。同时，异步的操作并不能保证任务一定会完成。



### 用户空间和内核空间

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。



### 同步阻塞IO

当某个IO操作没有准备好时，整个进程都被阻塞，无法去处理其它的IO操作，阻塞IO是Linux 中 socket 默认的处理方式。

分为两个流程：

> 1. kernel 等待IO数据并将数据存进内核缓冲区，在网络请求中，这个过程会比较耗时
> 2. kernel 将收到的数据从内核缓冲区中拷贝到进程内存空间

以上两步均为阻塞状态



### 同步非阻塞IO

当某个IO操作没有准备好时，尝试进行IO操作会立即返回一个错误代码，这时进程任然可以占用CPU去进行其它的事情，并不断检查这个IO操作有没有准备好，这个过程称之为**轮询**。比如在进行 ```recvfrom``` 操作时，就会去轮询检查内核数据，直到数据准备好，再拷贝数据到进程，注意拷贝的过程进程是处于阻塞状态的。

相比于同步阻塞IO，非阻塞的优点是可以在等待任务完成的时间里去做其它的事情，缺点是整个任务完成的响应延迟可能会增大，因为每过一段固定时间去检查数据是否准备好，而任务可能在两次轮询的任意时间内完成。



### IO 多路复用

进程通过某种机制同时监听多个IO操作，当某个IO操作就绪就通知进程进行相应的读写操作。这种机制就是 ```select, poll, epoll``` 函数，其好处是单个 process 就可以同时处理多个网络连接的IO，基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。实际上，在没有IO操作时，整个进程任然是阻塞的，只不过是阻塞在 select/poll 这些系统调用上，而不是阻塞在 IO 的系统调用上。

从消息通知的机制上来看，以上三种IO模型都是进程主动等待且向内核检查状态，因此它们都属于同步IO模型

#### select

通过维护一个fd数据结构轮询的检查是否有IO操作准备完毕，单个进程能打开的fd有上限，32位默认是1024，64位是2048

#### poll

本质上没有区别，也是线性遍历检查是否有fd准备好，基于链表存储，没有最大连接限制

#### epoll

epoll 与前两个最大的区别在于并不是以轮询的方式检查fd，而是采用一个 callback 函数，也就是事件驱动，在O(1)的时间内告知进程哪个fd准备好了。没有最大并发连接的限制，与内存大小有关，内部使用红黑树管理fd。epoll 对 fd 的处理方式有水平触发和边缘触发，水平触发是默认处理方式，指当内核通知你一个fd准备就绪了，你可以立即进行操作，如果不操作，epoll 会继续通知你；而边缘触发指只通知一次，如果你不对通知的fd进行操作，内核不会发送更多的通知。

总结一下，当连接数很多，且活跃的连接数很少时，那么epoll相对于前两者对性能的提升是巨大的；除了检查fd的方式不同之外，select/poll 消息传递的方式是从内核空间拷贝到用户空间，而epoll 是通过内核和用户空间共享一块内存实现的，因此效率更高。

### 信号驱动IO

首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。



### 异步非阻塞IO

用户进程进行 aio_read 系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。相当于是内核帮助进程完成了IO操作，并在完成后发送一个信号通知进程任务完成。